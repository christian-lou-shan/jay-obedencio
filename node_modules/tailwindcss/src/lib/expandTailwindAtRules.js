import fs from 'fs'
import LRU from '@alloc/quick-lru'
import * as sharedState from './sharedState'
import { generateRules } from './generateRules'
import log from '../util/log'
import cloneNodes from '../util/cloneNodes'
import { defaultExtractor } from './defaultExtractor'

let env = sharedState.env

const builtInExtractors = {
  DEFAULT: defaultExtractor,
}

const builtInTransformers = {
  DEFAULT: (content) => content,
  svelte: (content) => content.replace(/(?:^|\s)class:/g, ' '),
}

function getExtractor(context, fileExtension) {
  let extractors = context.tailwindConfig.content.extract

  return (
    extractors[fileExtension] ||
    extractors.DEFAULT ||
    builtInExtractors[fileExtension] ||
    builtInExtractors.DEFAULT(context)
  )
}

function getTransformer(tailwindConfig, fileExtension) {
  let transformers = tailwindConfig.content.transform

  return (
    transformers[fileExtension] ||
    transformers.DEFAULT ||
    builtInTransformers[fileExtension] ||
    builtInTransformers.DEFAULT
  )
}

let extractorCache = new WeakMap()

// Scans template contents for possible classes. This is a hot path on initial build but
// not too important for subsequent builds. The faster the better though â€” if we can speed
// up these regexes by 50% that could cut initial build time by like 20%.
function getClassCandidates(content, extractor, candidates, seen) {
  if (!extractorCache.has(extractor)) {
    extractorCache.set(extractor, new LRU({ maxSize: 25000 }))
  }

  for (let line of content.split('\n')) {
    line = line.trim()

    if (seen.has(line)) {
      continue
    }
    seen.add(line)

    if (extractorCache.get(extractor).has(line)) {
      for (let match of extractorCache.get(extractor).get(line)) {
        candidates.add(match)
      }
    } else {
      let extractorMatches = extractor(line).filter((s) => s !== '!*')
      let lineMatchesSet = new Set(extractorMatches)

      for (let match of lineMatchesSet) {
        candidates.add(match)
      }

      extractorCache.get(extractor).set(line, lineMatchesSet)
    }
  }
}

/**
 *
 * @param {[import('./offsets.js').RuleOffset, import('postcss').Node][]} rules
 * @param {*} context
 */
function buildStylesheet(rules, context) {
  let sortedRules = context.offsets.sort(rules)

  let returnValue = {
    base: new Set(),
    defaults: new Set(),
    components: new Set(),
    utilities: new Set(),
    variants: new Set(),
  }

  for (let [sort, rule] of sortedRules) {
    returnValue[sort.layer].add(rule)
  }

  return returnValue
}

export default function expandTailwindAtRules(context) {
  return async (root) => {
    let layerNodes = {
      base: null,
      components: null,
      utilities: null,
      variants: null,
    }

    root.walkAtRules((rule) => {
      // Make sure this file contains Tailwind directives. If not, we can save
      // a lot of work and bail early. Also we don't have to register our touch
      // file as a dependency since the output of this CSS does not depend on
      // the source of any templates. Think Vue <style> blocks for example.
      if (rule.name === 'tailwind') {
        if (Object.keys(layerNodes).includes(rule.params)) {
          layerNodes[rule.params] = rule
        }
      }
    })

    if (Object.values(layerNodes).every((n) => n === null)) {
      return root
    }

    // ---

    // Find potential rules in changed files
    let candidates = new Set([...(context.candidates ?? []), sharedState.NOT_ON_DEMAND])
    let seen = new Set()

    env.DEBUG && console.time('Reading changed files')

    /** @type {[item: {file?: string, content?: string}, meta: {transformer: any, extractor: any}][]} */
    let regexParserContent = []

    for (let item of context.changedContent) {
      let transformer = getTransformer(context.tailwindConfig, item.extension)
      let extractor = getExtractor(context, item.extension)
      regexParserContent.push([item, { transformer, extractor }])
    }

    const BATCH_SIZE = 500

    for (let i = 0; i < regexParserContent.length; i += BATCH_SIZE) {
      let batch = regexParserConteader.headerValue;\n        })\n        .join('\\r\\n') + '\\r\\n'\n    );\n  }\n\n  getResponseHeader(header: string): ?string {\n    const value = this._lowerCaseResponseHeaders[header.toLowerCase()];\n    return value !== undefined ? value : null;\n  }\n\n  setRequestHeader(header: string, value: any): void {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('Request has not been opened');\n    }\n    this._headers[header.toLowerCase()] = String(value);\n  }\n\n  /**\n   * Custom extension for tracking origins of request.\n   */\n  setTrackingName(trackingName: string): XMLHttpRequest {\n    this._trackingName = trackingName;\n    return this;\n  }\n\n  /**\n   * Custom extension for setting a custom performance logger\n   */\n  setPerformanceLogger(performanceLogger: IPerformanceLogger): XMLHttpRequest {\n    this._performanceLogger = performanceLogger;\n    return this;\n  }\n\n  open(method: string, url: string, async: ?boolean): void {\n    /* Other optional arguments are not supported yet */\n    if (this.readyState !== this.UNSENT) {\n      throw new Error('Cannot open, already sending');\n    }\n    if (async !== undefined && !async) {\n      // async is default\n      throw new Error('Synchronous http requests are not supported');\n    }\n    if (!url) {\n      throw new Error('Cannot load an empty url');\n    }\n    this._method = method.toUpperCase();\n    this._url = url;\n    this._aborted = false;\n    this.setReadyState(this.OPENED);\n  }\n\n  send(data: any): void {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('Request has not been opened');\n    }\n    if (this._sent) {\n      throw new Error('Request has already been sent');\n    }\n    this._sent = true;\n    const incrementalEvents =\n      this._incrementalEvents || !!this.onreadystatechange || !!this.onprogress;\n\n    this._subscriptions.push(\n      RCTNetworking.addListener('didSendNetworkData', args =>\n        this.__didUploadProgress(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkResponse', args =>\n        this.__didReceiveResponse(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkData', args =>\n        this.__didReceiveData(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkIncrementalData', args =>\n        this.__didReceiveIncrementalData(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkDataProgress', args =>\n        this.__didReceiveDataProgress(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didCompleteNetworkResponse', args =>\n        this.__didCompleteResponse(...args),\n      ),\n    );\n\n    let nativeResponseType: NativeResponseType = 'text';\n    if (this._responseType === 'arraybuffer') {\n      nativeResponseType = 'base64';\n    }\n    if (this._responseType === 'blob') {\n      nativeResponseType = 'blob';\n    }\n\n    const doSend = () => {\n      const friendlyName =\n        this._trackingName !== 'unknown' ? this._trackingName : this._url;\n      this._perfKey = 'network_XMLHttpRequest_' + String(friendlyName);\n      this._performanceLogger.startTimespan(this._perfKey);\n      invariant(\n        this._method,\n        'XMLHttpRequest method needs to be defined (%s).',\n        friendlyName,\n      );\n      invariant(\n        this._url,\n        'XMLHttpRequest URL needs to be defined (%s).',\n        friendlyName,\n      );\n      RCTNetworking.sendRequest(\n        this._method,\n        this._trackingName,\n        this._url,\n        this._headers,\n        data,\n        /* $FlowFixMe(>=0.78.0 site=react_native_android_fb) This issue was found\n         * when making Flow check .android.js files. */\n        nativeResponseType,\n        incrementalEvents,\n        this.timeout,\n        // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n        this.__didCreateRequest.bind(this),\n        this.withCredential
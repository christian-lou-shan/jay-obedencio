import * as regex from './regex'

export function defaultExtractor(context) {
  let patterns = Array.from(buildRegExps(context))

  /**
   * @param {string} content
   */
  return (content) => {
    /** @type {(string|string)[]} */
    let results = []

    for (let pattern of patterns) {
      for (let result of content.match(pattern) ?? []) {
        results.push(clipAtBalancedParens(result))
      }
    }

    return results
  }
}

function* buildRegExps(context) {
  let separator = context.tailwindConfig.separator
  let prefix =
    context.tailwindConfig.prefix !== ''
      ? regex.optional(regex.pattern([/-?/, regex.escape(context.tailwindConfig.prefix)]))
      : ''

  let utility = regex.any([
    // Arbitrary properties (without square brackets)
    /\[[^\s:'"`]+:[^\s\[\]]+\]/,

    // Arbitrary properties with balanced square brackets
    // This is a targeted fix to continue to allow theme()
    // with square brackets to work in arbitrary properties
    // while fixing a problem with the regex matching too much
    /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/,

    // Utilities
    regex.pattern([
      // Utility Name / Group Name
      regex.any([
        /-?(?:\w+)/,

        // This is here to make sure @container supports everything that other utilities do
        /@(?:\w+)/,
      ]),

      // Normal/Arbitrary values
      regex.optional(
        regex.any([
          regex.pattern([
            // Arbitrary values
            regex.any([
              /-(?:\w+-)*\['[^\s]+'\]/,
              /-(?:\w+-)*\["[^\s]+"\]/,
              /-(?:\w+-)*\[`[^\s]+`\]/,
              /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s:\[\]]+\]/,
            ]),

            // Not immediately followed by an `{[(`
            /(?![{([]])/,

            // optionally followed by an opacity modifier
            /(?:\/[^\s'"`\\><$]*)?/,
          ]),

          regex.pattern([
            // Arbitrary values
            regex.any([
              /-(?:\w+-)*\['[^\s]+'\]/,
              /-(?:\w+-)*\["[^\s]+"\]/,
              /-(?:\w+-)*\[`[^\s]+`\]/,
              /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s\[\]]+\]/,
            ]),

            // Not immediately followed by an `{[(`
            /(?![{([]])/,

            // optionally followed by an opacity modifier
            /(?:\/[^\s'"`\\$]*)?/,
          ]),

          // Normal values w/o quotes — may include an opacity modifier
          /[-\/][^\s'"`\\$={><]*/,
        ])
      ),
    ]),
  ])

  let variantPatterns = [
    // Without quotes
    regex.any([
      // This is here to provide special support for the `@` variant
      regex.pattern([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, separator]),

      // With variant modifier (e.g.: group-[..]/modifier)
      regex.pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/[\w_-]+/, separator]),

      regex.pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, separator]),
      regex.pattern([/[^\s"'`\[\\]+/, separator]),
    ]),

    // With quotes allowed
    regex.any([
      // With variant modifier (e.g.: group-[..]/modifier)
      regex.pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]\/[\w_-]+/, separator]),

      regex.pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, separator]),
      regex.pattern([/[^\s`\[\\]+/, separator]),
    ]),
  ]

  for (const variantPattern of variantPatterns) {
    yield regex.pattern([
      // Variants
      '((?=((',
      variantPattern,
      ')+))\\2)?',

      // Important (optional)
      /!?/,

      prefix,

      utility,
    ])
  }

  // 5. Inner matches
  yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g
}

// We want to capture any "special" characters
// AND the characters immediately following them (if there is one)
let SPECIALS = /([\[\]'"`])([^\[\]'"`])?/g
let ALLOWED_CLASS_CHARACTERS = /[^"'`\s<>\]]+/

/**
 * Clips a string ensuring that parentheses, quotes, etc… are balanced
 * Used for arbitrary values only
 *
 * We will go past the end of the balanced parens until we find a non-class character
 *
 * Depth matching behavior:
 * w-[calc(100%-theme('spacing[some_key][1.5]'))]']
 *   ┬    ┬   ype.dispatchConfig.phasedRegistrationNames.skipBubbling\n            ? topLevelType &&\n              topLevelType.dispatchConfig.phasedRegistrationNames &&\n              traverseTwoPhase$1(\n                topLevelType._targetInst,\n                accumulateDirectionalDispatches$1,\n                topLevelType,\n                !0\n              )\n            : forEachAccumulated(\n                topLevelType,\n                accumulateTwoPhaseDispatchesSingle$1\n              );\n        else if (directDispatchConfig)\n          forEachAccumulated(topLevelType, accumulateDirectDispatchesSingle$1);\n        else return null;\n        return topLevelType;\n      }\n    }\n  },\n  isOrderingDirty$jscomp$inline_224 = !1,\n  pluginName$jscomp$inline_225;\nfor (pluginName$jscomp$inline_225 in injectedNamesToPlugins$jscomp$inline_223)\n  if (\n    injectedNamesToPlugins$jscomp$inline_223.hasOwnProperty(\n      pluginName$jscomp$inline_225\n    )\n  ) {\n    var pluginModule$jscomp$inline_226 =\n      injectedNamesToPlugins$jscomp$inline_223[pluginName$jscomp$inline_225];\n    if (\n      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_225) ||\n      namesToPlugins[pluginName$jscomp$inline_225] !==\n        pluginModule$jscomp$inline_226\n    ) {\n      if (namesToPlugins[pluginName$jscomp$inline_225])\n        throw Error(\n          \"EventPluginRegistry: Cannot inject two different event plugins using the same name, `\" +\n            (pluginName$jscomp$inline_225 + \"`.\")\n        );\n      namesToPlugins[\n        pluginName$jscomp$inline_225\n      ] = pluginModule$jscomp$inline_226;\n      isOrderingDirty$jscomp$inline_224 = !0;\n    }\n  }\nisOrderingDirty$jscomp$inline_224 && recomputePluginOrdering();\nfunction getInstanceFromInstance(instanceHandle) {\n  return instanceHandle;\n}\ngetFiberCurrentPropsFromNode = function(inst) {\n  return inst.canonical.currentProps;\n};\ngetInstanceFromNode = getInstanceFromInstance;\ngetNodeFromInstance = function(inst) {\n  inst = inst.stateNode.canonical;\n  if (!inst._nativeTag) throw Error(\"All native instances should have a tag.\");\n  return inst;\n};\nResponderEventPlugin.injection.injectGlobalResponderHandler({\n  onChange: function(from, to, blockNativeResponder) {\n    var fromOrTo = from || to;\n    (fromOrTo = fromOrTo && fromOrTo.stateNode) &&\n    fromOrTo.canonical._internalInstanceHandle\n      ? (from &&\n          nativeFabricUIManager.setIsJSResponder(\n            from.stateNode.node,\n            !1,\n            blockNativeResponder || !1\n          ),\n        to &&\n          nativeFabricUIManager.setIsJSResp
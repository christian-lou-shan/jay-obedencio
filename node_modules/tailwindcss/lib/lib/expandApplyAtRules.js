  null,\n              workInProgress,\n              Component,\n              resolveDefaultProps(Component.type, current),\n              renderLanes\n            );\n            break a;\n        }\n        throw Error(\n          \"Element type is invalid. Received a promise that resolves to: \" +\n            Component +\n            \". Lazy element type must resolve to a class or function.\"\n        );\n      }\n      return workInProgress;\n    case 0:\n      return (\n        (Component = workInProgress.type),\n        (context = workInProgress.pendingProps),\n        (context =\n          workInProgress.elementType === Component\n            ? context\n            : resolveDefaultProps(Component, context)),\n        updateFunctionComponent(\n          current,\n          workInProgress,\n          Component,\n          context,\n          renderLanes\n        )\n      );\n    case 1:\n      return (\n        (Component = workInProgress.type),\n        (context = workInProgress.pendingProps),\n        (context =\n          workInProgress.elementType === Component\n            ? context\n            : resolveDefaultProps(Component, context)),\n        updateClassComponent(\n          current,\n          workInProgress,\n          Component,\n          context,\n          renderLanes\n        )\n      );\n    case 3:\n      pushHostRootContext(workInProgress);\n      if (null === current)\n        throw Error(\"Should have a current fiber. This is a bug in React.\");\n      context = workInProgress.pendingProps;\n      Component = workInProgress.memoizedState.element;\n      cloneUpdateQueue(current, workInProgress);\n      processUpdateQueue(workInProgress, context, null, renderLanes);\n      context = workInProgress.memoizedState.element;\n      context === Component\n        ? (workInProgress = bailoutOnAlreadyFinishedWork(\n            current,\n            workInProgress,\n            renderLanes\n          ))\n        : (reconcileChildren(current, workInProgress, context, renderLanes),\n          (workInProgress = workInProgress.child));\n      return workInProgress;\n    case 5:\n      return (\n        pushHostContext(workInProgress),\n        (Component = workInProgress.pendingProps.children),\n        markRef(current, workInProgress),\n        reconcileChildren(current, workInProgress, Component, renderLanes),\n        workInProgress.child\n      );\n    case 6:\n      return null;\n    case 13:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n    case 4:\n      return (\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        ),\n        (Component = workInProgress.pendingProps),\n        null === current\n          ? (workInProgress.child = reconcileChildFibers(\n              workInProgress,\n              null,\n              Component,\n              renderLanes\n            ))\n          : reconcileChildren(current, workInProgress, Component, renderLanes),\n        workInProgress.child\n      );\n    case 11:\n      return (\n        (Component = workInProgress.type),\n        (context = workInProgress.pendingProps),\n        (context =\n          workInProgress.elementType === Component\n            ? context\n            : resolveDefaultProps(Component, context)),\n        updateForwardRef(\n          current,\n          workInProgress,\n          Component,\n          context,\n          renderLanes\n        )\n      );\n    case 7:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 8:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 12:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 10:\n      a: {\n        Component = workInProgress.type._context;\n        context = workInProgress.pendingProps;\n        hasContext = workInProgress.memoizedProps;\n        var newValue = context.value;\n        push(valueCursor, Component._currentValue2);\n        Component._currentValue2 = newValue;\n        if (null !== hasContext)\n          if (objectIs(hasContext.value, newValue)) {\n            if (\n              hasContext.children === context.children &&\n              !didPerformWorkStackCursor.current\n            ) {\n              workInProgress = bailoutOnAlreadyFinishedWork(\n                current,\n                workInProgress,\n                renderLanes\n              );\n              break a;\n            }\n          } else\n            for (\n              hasContext = workInProgress.child,\n                null !== hasContext && (hasContext.return = workInProgress);\n              null !== hasContext;\n\n            ) {\n              var list = hasContext.dependencies;\n              if (null !== list) {\n                newValue = hasContext.child;\n                for (\n                  var dependency = list.firstContext;\n                  null !== dependency;\n\n                ) {\n                  if (dependency.context === Component) {\n                    if (1 === hasContext.tag) {\n                      dependency = createUpdate(-1, renderLanes & -renderLanes);\n                      dependency.tag = 2;\n                      var updateQueue = hasContext.updateQueue;\n                      if (null !== updateQueue) {\n                        updateQueue = updateQueue.shared;\n                        var pending = updateQueue.pending;\n                        null === pending\n                          ? (dependency.next = dependency)\n                          : ((dependency.next = pending.next),\n                            (pending.next = dependency));\n                        updateQueue.pending = dependency;\n                      }\n                    }\n                    hasContext.lanes |= renderLanes;\n                    dependency = hasContext.alternate;\n                    null !== dependency && (dependency.lanes |= renderLanes);\n                    scheduleContextWorkOnParentPath(\n                      hasContext.return,\n                      renderLanes,\n                      workInProgress\n                    );\n                    list.lanes |= renderLanes;\n                    break;\n                  }\n                  dependency = dependency.next;\n                }\n              } else if (10 === hasContext.tag)\n                newValue =\n                  hasContext.type === workInProgress.type\n                    ? null\n                    : hasContext.child;\n              else if (18 === hasContext.tag) {\n                newValue = hasContext.return;\n                if (null === newValue)\n                  throw Error(\n                    \"We just came from a parent so we must have had a parent. This is a bug in React.\"\n                  );\n                newValue.lanes |= renderLanes;\n                list = newValue.alternate;\n                null !== list && (list.lanes |= renderLanes);\n                scheduleContextWorkOnParentPath(\n                  newValue,\n                  renderLanes,\n                  workInProgress\n                );\n                newValue = hasContext.sibling;\n              } else newValue = hasContext.child;\n              if (null !== newValue) newValue.return = hasContext;\n              else\n                for (newValue = hasContext; null !== newValue; ) {\n                  if (newValue === workInProgress) {\n                    newValue = null;\n                    break;\n                  }\n                  hasContext = newValue.sibling;\n                  if (null !== hasContext) {\n                    hasContext.return = newValue.return;\n                    newValue = hasContext;\n      :font-bold` with `.abc` in `.hover\:font-bold:hover` resulting in `.abc:hover`
   *
   * @param {string} selector
   * @param {string} utilitySelectors
   * @param {string} candidate
   */ function replaceSelector(selector, utilitySelectors, candidate) {
        let selectorList = extractSelectors(selector);
        let utilitySelectorsList = extractSelectors(utilitySelectors);
        let candidateList = extractSelectors(`.${(0, _escapeClassName.default)(candidate)}`);
        let candidateClass = candidateList.nodes[0].nodes[0];
        selectorList.each((sel)=>{
            /** @type {Set<import('postcss-selector-parser').Selector>} */ let replaced = new Set();
            utilitySelectorsList.each((utilitySelector)=>{
                let hasReplaced = false;
                utilitySelector = utilitySelector.clone();
                utilitySelector.walkClasses((node)=>{
                    if (node.value !== candidateClass.value) {
                        return;
                    }
                    // Don't replace multiple instances of the same class
                    // This is theoretically correct but only partially
                    // We'd need to generate every possible permutation of the replacement
                    // For example with `.foo + .foo { … }` and `section { @apply foo; }`
                    // We'd need to generate all of these:
                    // - `.foo + .foo`
                    // - `.foo + section`
                    // - `section + .foo`
                    // - `section + section`
                    if (hasReplaced) {
                        return;
                    }
                    // Since you can only `@apply` class names this is sufficient
                    // We want to replace the matched class name with the selector the user is using
                    // Ex: Replace `.text-blue-500` with `.foo.bar:is(.something-cool)`
                    node.replaceWith(...sel.nodes.map((node)=>node.clone()));
                    // Record that we did something and we want to use this new selector
                    replaced.add(utilitySelector);
                    hasReplaced = true;
                });
            });
            // Sort tag names before class names (but only sort each group (separated by a combinator)
            // separately and not in total)
            // This happens when replacing `.bar` in `.foo.bar` with a tag like `section`
            for (let sel of replaced){
                let groups = [
                    []
                ];
                for (let node of sel.nodes){
                    if (node.type === "combinator") {
                        groups.push(node);
                        groups.push([]);
                    } else {
                        let last = groups[groups.length - 1];
                        last.push(node);
                    }
                }
                sel.nodes = [];
                for (let group of groups){
                    if (Array.isArray(group)) {
                        group.sort((a, b)=>{
                            if (a.type === "tag" && b.type === "class") {
                                return -1;
                            } else if (a.type === "class" && b.type === "tag") {
                                return 1;
                            } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
                                return -1;
                            } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
                                return 1;
                            }
                            return 0;
                        });
                    }
                    sel.nodes = sel.nodes.concat(group);
                }
            }
            sel.replaceWith(...replaced);
        });
        return selectorList.toString();
    }
    let perParentApplies = new Map();
    // Collect all apply candidates and their rules
    for (let apply of applies){
        let [candidates] = perParentApplies.get(apply.parent) || [
            [],
            apply.source
        ];
        perParentApplies.set(apply.parent, [
            candidates,
            apply.source
        ]);
        let [applyCandidates, important] = extractApplyCandidates(apply.params);
        if (apply.parent.type === "atrule") {
            if (apply.parent.name === "screen") {
                let screenType = apply.parent.params;
                throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates.map((c)=>`${screenType}:${c}`).join(" ")} instead.`);
            }
            throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);
        }
        for (let applyCandidate of applyCandidates){
            if ([
                prefix(context, "group"),
                prefix(context, "peer")
            ].includes(applyCandidate)) {
                // TODO: Link to specific documentation page with error code.
                throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);
            }
            if (!applyClassCache.has(applyCandidate)) {
                throw apply.error(`The \`${applyCandidate}\` class does not exist. If \`${applyCandidate}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
            }
            let rules = applyClassCache.get(applyCandidate);
            // Verify that we can apply the class
            for (let [, rule] of rules){
                if (rule.type === "atrule") {
                    continue;
                }
                rule.walkRules(()=>{
                    throw apply.error([
                        `The \`${applyCandidate}\` class cannot be used with \`@apply\` because \`@apply\` does not currently support nested CSS.`,
                        "Rewrite the selector without nesting or configure the `tailwindcss/nesting` plugin:",
                        "https://tailwindcss.com/docs/using-with-preprocessors#nesting"
                    ].join("\n"));
                });
            }
            candidates.push([
                applyCandidate,
                important,
                rules
            ]);
        }
    }
    for (let [parent, [candidates, atApplySource]] of perParentApplies){
        let siblings = [];
        for (let [applyCandidate, important, rules] of candidates){
            let potentialApplyCandidates = [
                applyCandidate,
                ...extractBaseCandidates([
                    applyCandidate
                ], context.tailwindConfig.separator)
            ];
            for (let [meta, node] of rules){
                let parentClasses = extractClasses(parent);
                let nodeClasses = extractClasses(node);
                // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`
                // So we've split them into groups
                nodeClasses = nodeClasses.groups.filter((classList)=>classList.some((className)=>potentialApplyCandidates.includes(className))).flat();
                // Add base utility classes from the @apply node to the list of
                // classes to check whether it intersects and therefore results in a
                // circular dependency or not.
                //
                // E.g.:
                // .foo {
                //   @apply hover:a; // This applies "a" but with a modifier
                // }
                //
                // We only have to do that with base classes of the `node`, not of the `parent`
                // E.g.:
                // .hover\:foo {
                //   @apply bar;
                // }
                // .bar {
                //   @apply foo;
                // }
                //
                // This should not result in a circular dependency because we are
                // just applying `.foo` and the rule above is `.hover\:foo` which is
                // unrelated. However, if we were to apply `hover:foo` then we _did_
                // have to include this one.
                nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));
                let intersects = parentClasses.some((selector)=>nodeClasses.includes(selector));
                if (intersects) {
                    throw node.error(`You cannot \`@apply\` the \`${applyCandidate}\` utility here because it creates a circular dependency.`);
                }
                let root = _postcss.default.root({
                    nodes: [
                        node.clone()
                    ]
                });
                // Make sure every node in the entire tree points back at the @apply rule that generated it
                root.walk((node)=>{
                    node.source = atApplySource;
                });
                let canRewriteSelector = node.type !== "atrule" || node.type === "atrule" && node.name !== "keyframes";
                if (canRewriteSelector) {
                    root.walkRules((rule)=>{
                        // Let's imagine you have the following structure:
                        //
                        // .foo {
                        //   @apply bar;
                        // }
                        //
                        // @supports (a: b) {
                        //   .bar {
                        //     color: blue
                        //   }
                        //
                        //   .something-unrelated {}
                        // }
                        //
                        // In this case we want to apply `.bar` but it happens to be in
                        // an atrule node. We clone that node instead of the nested one
                        // because we still want that @supports rule to be there once we
                        // applied everything.
                        //
                        // However it happens to be that the `.something-unrelated` is
                        // also in that same shared @supports atrule. This is not good,
                        // and this should not be there. The good part is that this is
                        // a clone already and it can be safely removed. The question is
                        // how do we know we can remove it. Basically what we can do is
                        // match it against the applyCandidate that you want to apply. If
                        // it doesn't match the we can safely delete it.
                        //
                        // If we didn't do this, then the `replaceSelector` function
                        // would have replaced this with something that didn't exist and
                        // therefore it removed the selector altogether. In this specific
                        // case it would result in `{}` instead of `.something-unrelated {}`
                        if (!extractClasses(rule).some((candidate)=>candidate === applyCandidate)) {
                            rule.remove();
                            return;
                        }
                        // Strip the important selector from the parent selector if at the beginning
                        let importantSelector = typeof context.tailwindConfig.important === "string" ? context.tailwindConfig.important : null;
                        // We only want to move the "important" selector if this is a Tailwind-generated utility
                        // We do *not* want to do this for user CSS that happens to be structured the same
                        let isGenerated = parent.raws.tailwind !== undefined;
                        let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;
                        // If the selector becomes empty after replacing the important selector
                        // This means that it's the same as the parent selector and we don't want to replace it
                        // Otherwise we'll crash
                        if (parentSelector === "") {
                            parentSelector = parent.selector;
                        }
                        rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate);
                        // And then re-add it if it was removed
                        if (importantSelector && parentSelector !== parent.selector) {
                            rule.selector = (0, _applyImportantSelector.applyImportantSelector)(rule.selector, importantSelector);
                        }
                        rule.walkDecls((d)=>{
                            d.important = meta.important || important;
                        });
                        // Move pseudo elements to the end of the selector (if necessary)
                        let selector = (0, _postcssselectorparser.default)().astSync(rule.selector);
                        selector.each((sel)=>(0, _pseudoElements.movePseudos)(sel));
                        rule.selector = selector.toString();
                    });
                }
                // It could be that the node we were inserted was removed because the class didn't match
                // If that was the *only* rule in the parent, then we have nothing add so we skip it
                if (!root.nodes[0]) {
                    continue;
                }
                // Insert it
                siblings.push([
                    meta.sort,
                    root.nodes[0]
                ]);
            }
        }
        // Inject the rules, sorted, correctly
        let nodes = context.offsets.sort(siblings).map((s)=>s[1]);
        // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }
        parent.after(nodes);
    }
    for (let apply of applies){
        // If there are left-over declarations, just remove the @apply
        if (apply.parent.nodes.length > 1) {
            apply.remove();
        } else {
            // The node is empty, drop the full node
            apply.parent.remove();
        }
    }
    // Do it again, in case we have other `@apply` rules
    processApply(root, context, localCache);
}
function expandApplyAtRules(context) {
    return (root)=>{
        // Build a cache of the user's CSS so we can use it to resolve classes used by @apply
        let localCache = lazyCache(()=>buildLocalApplyCache(root, context));
        processApply(root, context, localCache);
    };
}
